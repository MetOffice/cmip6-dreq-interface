#!/usr/bin/env python2.7
# -*- mode: Python -*-
#
# (C) British Crown Copyright 2016, Met Office.
# See LICENSE.md in the top directory for license details.
#

# Find something close to the best assignment of reviewers for
# diagnostics.
#
# A reviewer is eligible to review a diagnostic if they are either the
# expert for its component, or the leader of a MIP which it partakes in.
# The best assignment is the one which has the most even load among
# eligible reviewers.  This does not actually compute that, because it
# assigns dvictims based only on what diagnostics it has seen so far,
# and does not try to do any global optimisation.  But it is probably
# close enough.
#
# (For instance if d1 belongs to m1 and m2, and p1 is the leader of m1
# it might assign d1 to p1, but then it might see a bunch of
# diagnostics which belong to m1 only, which will mean that m2's
# leader, who could have reviewed d1, gets no work to do.)
#
# Where multiple reviewers are possible (ie there are several eligible
# people who have no more than the fewest diagnostics to review so
# far) one is chosen pseudorandomly.  You can seed the PRNG to make
# the results repeatable.
#
# This takes four JSON files as input, each of which contains a
# JSON object.  They are, in order:
# - diag2component maps diagnostics to their components (both strings);
# - component2expert maps components to their experts (both strings);
# - diag2mips maps diagnostics to their mips (diagnostics are strings,
#   mips are arrays of strings);
# - mip2lead maps mips to their leaders (both strings).
#
# All diagnostics must have both a component and some mips (an empty list
# of mips is allowed, but they must appear in the mapping file), all
# components must have experts and all mips must have leaders: this is
# checked and the program will puke if this is not the case.
#
# Switches:
#   -s seed the PRNG with an integer
#   -d will cause backtraces not to be suppressed;
#   -j will make JSON output
#
# This is not heavily tested
#

from sys import stdin, stdout, argv
from signal import SIGINT
from os import _exit, EX_IOERR
from argparse import ArgumentParser
from json import load, dump
from random import seed, choice

class BadJSON(Exception):
    pass

class InsaneMappings(Exception):
    pass

def main():
    backtrace = None
    parser = ArgumentParser(description="print reviewers for diagnostics")
    parser.add_argument("-d", "--debug",
                        action='store_true', dest='debug',
                        help="don't suppress backtraces")
    parser.add_argument("-j", "--json",
                        action='store_true', dest='as_json',
                        help="generate JSON output")
    parser.add_argument("-s", "--seed", type=int,
                        dest='random_seed', default=None,
                        help="seed for the random number generator")
    parser.add_argument("diag2component", nargs=1,
                        help="JSON file mapping diagnostics to components")
    parser.add_argument("component2expert", nargs=1,
                        help="JSON file mapping components to their expert")
    parser.add_argument("diag2mips", nargs=1,
                        help="JSON file mapping diagnostics to lists of MIPs")
    parser.add_argument("mip2lead", nargs=1,
                        help="JSON file mapping MIPs to their leads")
    try:
        args = parser.parse_args()
        backtrace = args.debug
        spit(grovel(d2c=jread(args.diag2component[0]),
                    c2e=jread(args.component2expert[0]),
                    d2ms=jread(args.diag2mips[0], listy=True),
                    m2l=jread(args.mip2lead[0]),
                    random_seed=args.random_seed),
             as_json=args.as_json)
    except Exception as e:
        if not backtrace:
            exit(e)
        elif backtrace is None:
            print >>stderr, "{}: very early badness".format(argv[0])
            raise
        else:
            raise
    except KeyboardInterrupt as e:
        exit(128 + SIGINT)

    # Try and evade the 'lost stderr' spurions by just bottling out
    #
    try:
        stdout.flush()
        stdout.close()
        stderr.flush()
        stderr.close()
    except:
        _exit(EX_IOERR)

def jread(json_file, listy=False):
    # read json_file, check it smells right and return the dict if
    # listy is true then it maps keys to lists of stringy things,
    # otherwise it maps keys to stringy things
    #
    with open(json_file) as jp:
        table = load(jp)
    if not isinstance(table, dict):
        raise BadJSON("not even a dict in {}".format(json_file))
    for (k, v) in table.iteritems():
        if not stringlike(k):
            raise BadJSON("bogus key {} in {}".format(k, json_file))
        if not listy:
            if not stringlike(v):
                raise BadJSON("bogus value {} in {}".format(v, json_file))
        else:
            if not arraylike(v):
                raise BadJSON("{} should be arraylike in {}"
                              .format(v, json_file))
            for e in v:
                if not stringlike(e):
                    raise BadJSON("{} should be strings in {}"
                                  .format(v, json_file))
    return table

def grovel(d2c, c2e, d2ms, m2l, random_seed=None):
    # Grovel the mappings into a set of assignments:
    # - d2c maps diagnostics to components
    # - c2e maps components to experts
    # - d2ms maps diagnostics to lists of mips
    # - m2l maps a mip to its leader
    #
    # Return a dictionary mapping victims to lists of diagnostics they
    # need to review.  See commentary above.
    #
    # For given input, this should be deterministic if the same seed
    # is specified.
    #
    # check the mappings are sane so we can assume it later.
    sanity(d2c, c2e, d2ms, m2l)
    if random_seed is not None:
        seed(random_seed)
    # start with empty assignments for each expert and mip lead (the
    # possible victims)
    assignments = {p: [] for p in set(c2e.values()) | set(m2l.values())}
    # sorting the diagnostics makes it not depend on hash order
    for (d, c) in sorted(d2c.iteritems(), key=lambda e: e[0]):
        # for each diagnostic, the expert of its component is eligible,
        # and the leaders of all its mips are eligible
        eligible = {c2e[c]} | {m2l[m] for m in d2ms[d]}
        # The possible victims are those who have no more diagnostics
        # to review than the person with fewest.  Again, sort so we
        # don't depend on hash order.
        fewest = min(assignments[e] for e in eligible)
        victims = sorted(e for e in eligible if assignments[e] == fewest)
        # And now pick a victim pseudorandomly
        victim = choice(victims)
        # and add the diagnostic to the assignments for the victim
        assignments[victim].append(d)
    return assignments

def sanity(d2c, c2e, d2ms, m2l):
    # Sanity check mappings, raising an exception if doomed
    # - d2c maps diagnostics to components
    # - c2e maps components to experts
    # - d2ms maps diagnostics to lists of mips
    # - m2l maps a mip to its leader
    #
    # Every diagnostic must be on the LHS of both d2c and d2ms
    if set(d2c.keys()) != set(d2ms.keys()):
        raise InsaneMappings("botched diagnostics")
    # every component must be on the LHS of c2e
    if not set(d2c.values()) <= set(c2e.keys()):
        raise InsaneMappings("orphaned component")
    # every mip must be on the LHS of m2l
    if not set(m for ms in d2ms.values() for m in ms) <= set(m2l.keys()):
        raise InsaneMappings("orphaned mip")

def spit(mappings, as_json=False):
    # Print the mappings, possibly as JSON
    if not as_json:
        for (victim, diags) in sorted(mappings.iteritems(), key=lambda e: e[0]):
            if len(diags) > 0:
                # if printing just text don't mention people with
                # nothing to do
                print victim,
                for d in diags:
                    print d,
                print
    else:
        dump(mappings, stdout, sort_keys=True, indent=1)
        print

# Some type predicates
#

def stringlike(x):
    return isinstance(x, unicode) or isinstance(x, str)

def arraylike(x):
    return isinstance(x, list) or isinstance(x, tuple)

# Go
#
if __name__ == '__main__':
    main()
