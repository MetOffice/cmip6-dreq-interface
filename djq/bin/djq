#!/usr/bin/env python2.7
# -*- mode: Python -*-
#
# Top-level djq script
#
# This only handles the minimal things needed to wrap functionality
# from djq and handle exceptions which propagate to the top-level.
#

from sys import stdin, stdout, argv
from signal import SIGINT
from os import _exit, EX_IOERR
from argparse import ArgumentParser
from importlib import import_module
from djq import default_dqroot, valid_dqroot, default_dqtag, valid_dqtag
from djq import process_stream
from djq.low import verbosity_level, debug_level, mutter
from djq.low import ExternalException, Scram
from djq.low import enable_checks
from djq.variables import cv_implementation, jsonify_implementation

class BadRoot(ExternalException):
    def __init__(self, dqroot):
        self.dqroot = dqroot
    def __str__(self):
        return "bad root {}".format(self.dqroot)

class BadTag(ExternalException):
    def __init__(self, dqtag):
        self.dqtag = dqtag
    def __str__(self):
        return "bad tag {} for root {}".format(self.dqtag, default_dqroot())

def main():
    parser = ArgumentParser(description="DREQ JSON Query tool")
    parser.add_argument("-r", "--root",
                        default=None, dest='dqroot',
                        help="the top of a checked out CMIP6 DREQ")
    parser.add_argument("-t", "--tag",
                        default=None, dest='dqtag',
                        help="the default tag for the DREQ")
    parser.add_argument("-i", "--implementation",
                        default=None, dest='implementation',
                        help="the name of an implementation to load")
    parser.add_argument("-j", "--jsonify-implementation",
                        default=None, dest='jsonify_implementation',
                        help="the name of a JSONify implementation to load")
    parser.add_argument("-v", "--verbose",
                        action='count', dest='verbosity',
                        help="increase verbosity (repeat for more noise)")
    parser.add_argument("-d", "--debug",
                        action='count', dest='debug',
                        help="debugging output (repeat for, perhaps, more)")
    parser.add_argument("-b", "--backtrace",
                        action='store_true', dest='backtrace',
                        help="don't suppress backtraces")
    parser.add_argument("-c", "--check-priority",
                        action='store', type=int,
                        dest='check_priority', default=0,
                        help="set the lowest check priority that will run")
    parser.add_argument("-o", "--output",
                        default=None, dest='output',
                        help="output file (stdout default)")
    parser.add_argument('request', nargs='?', default=None,
                        help="JSON request (stdin default)")
    backtrace = None
    try:
        args = parser.parse_args()
        backtrace = args.backtrace
        debug_level(args.debug)
        verbosity_level(args.verbosity)
        enable_checks(minpri=args.check_priority)
        if args.implementation is not None:
            cv_implementation(import_module(args.implementation))
        if args.jsonify_implementation is not None:
            jsonify_implementation(import_module(args.jsonify_implementation))
        if args.dqroot is not None:
            default_dqroot(args.dqroot)
        # root can be checked, tag can't in general because it can be
        # set in requests
        if not valid_dqroot():
            raise BadRoot(default_dqroot())
        if args.dqtag is not None:
            # but we can check it here
            if not valid_dqtag(tag=args.dqtag):
                raise BadTag(args.dqtag)
            default_dqtag(args.dqtag)
        mutter("root {} tag {}", default_dqroot(), default_dqtag())
        if args.implementation is not None:
            mutter("implementation {}",
                   (args.implementation.__name__
                    if hasattr(args.implementation, '__name__')
                    else args.implementation))
        if args.jsonify_implementation is not None:
            mutter("jsonify_implementation {}",
                   (args.jsonify_implementation.__name__
                    if hasattr(args.jsonify_implementation, '__name__')
                    else args.jsonify_implementation))
        mutter("from {} to {}",
               (args.request if args.request is not None else "-"),
               (args.output if args.output is not None else "-"))
        with (open(args.request)
              if args.request is not None
              else stdin) as input, (open(args.output, 'w')
                                     if args.output is not None
                                     else stdout) as output:
            process_stream(input, output, backtrace=backtrace)
    except Scram as e:
        raise
    except Exception as e:
        if not backtrace:
            exit(e)
        elif backtrace is None:
            print >>stderr, "{}: very early badness".format(argv[0])
            raise
        else:
            raise
    except KeyboardInterrupt as e:
        exit(128 + SIGINT)

    # Try and evade the 'lost stderr' spurions by just bottling out
    #
    try:
        stdout.flush()
        stdout.close()
        stderr.flush()
        stderr.close()
    except:
        _exit(EX_IOERR)

if __name__ == '__main__':
    main()
